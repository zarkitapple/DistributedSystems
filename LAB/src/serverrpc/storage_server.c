/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "storage.h"
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys/types.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#define USERS_DIRECTORY "./Users"

pthread_mutex_t data_mutex;
pthread_mutex_t list_mutex;

List * connected_users;

void init_server () {
	connected_users = create_list();
    pthread_mutex_init(&data_mutex,NULL);
    pthread_mutex_init(&list_mutex,NULL);
}

void dumb_data_error(TitleList *resultTitle, UserList *resultUsers,int mode){

	char dumb_data [4] = "-1";

	if(mode == 0) {
		Title tmp;
		tmp.file_name = malloc(MAX_SIZE);
		
		strcpy(tmp.file_name,dumb_data);
		resultTitle->TitleList_len = 1;
		resultTitle->TitleList_val = malloc(sizeof(Title));
		resultTitle->TitleList_val[0] = tmp;
	}
	else if (mode == 2)
	{
		char data [4] = "-2";
		Title tmp;
		tmp.file_name = malloc(MAX_SIZE);

		strcpy(tmp.file_name,data);
		resultTitle->TitleList_len = 1;
		resultTitle->TitleList_val = malloc(sizeof(Title));
		resultTitle->TitleList_val[0] = tmp;
	}
	
	else {
		UserServer tmp;
		tmp.name = malloc(MAX_SIZE);
		tmp.ip = malloc(IP_SIZE);
		tmp.port = malloc(PORT_SIZE);

		strcpy(tmp.name,dumb_data);
		strcpy(tmp.ip,dumb_data);
		strcpy(tmp.port,dumb_data);

		resultUsers->UserList_len = 1;
		resultUsers->UserList_val = malloc(sizeof(UserServer));
		resultUsers->UserList_val[0] = tmp;
	}	
}


bool_t
register_user_rpc_1_svc(char *arg1, int *result,  struct svc_req *rqstp)
{
	if(isusr_registered(arg1)) {
		/* User already registered */
		*result = 1;
		return TRUE;
	}

	size_t directory_size = strlen(arg1) + 2 + strlen(USERS_DIRECTORY) + 1;
	char * dir_path = (char *)malloc(directory_size * sizeof(char));
	sprintf(dir_path,"%s/%s",USERS_DIRECTORY,arg1);

	if(mkdir(dir_path,0777)==-1){
		perror("Cannot create user directory");
		free(dir_path);
		*result = 2;
		return TRUE;
	}
	free(dir_path);
	*result = 0;
	return TRUE;
}

bool_t
unregister__user_rpc_1_svc(char *arg1, int *result,  struct svc_req *rqstp)
{
	if(!isusr_registered(arg1)) {
		/* User already registered */
		*result = 1;
		return TRUE;
	}

	size_t directory_size = strlen(arg1) + 2 + strlen(USERS_DIRECTORY) + 1;
	char * dir_path = (char *)malloc(directory_size * sizeof(char));
	sprintf(dir_path,"%s/%s",USERS_DIRECTORY,arg1);
	/* Remove directory entry */
	if((remove_directory(dir_path))==-1) {
		perror("Error when deleting users data");
		free(dir_path);
		*result = 2;
		return TRUE;
	}
	/* remove from connected */
	delete_element(arg1,connected_users);
	free(dir_path);
	*result = 0;
	return TRUE;
}

bool_t
connect_user_rpc_1_svc(connect_arguments arg1, int *result,  struct svc_req *rqstp)
{
	if(!isusr_registered(arg1.name)){
		*result = 1;
		return TRUE;
	}
	if(find_element_byname(connected_users,arg1.name)){
		*result = 2;
		return TRUE;
	}

	UserServerData tmp;

	strcpy(tmp.name,arg1.name);
	strcpy(tmp.port,arg1.port);
	strcpy(tmp.ip_address,arg1.ip);

	add_element(&tmp,connected_users);
	print_list(connected_users);
	*result = 0;
	return TRUE;
}

bool_t
disconnect_user_rpc_1_svc(char *arg1, int *result,  struct svc_req *rqstp)
{
	if(!isusr_registered(arg1)){
		*result = 1;
		return TRUE;
	}
	if(!find_element_byname(connected_users,arg1)){
		*result = 2;
		return TRUE;
	}
	delete_element(arg1,connected_users);

	*result = 0;
	return TRUE;
}

bool_t
publish_file_rpc_1_svc(publish_arguments arg1, int *result,  struct svc_req *rqstp)
{
	if(!isusr_registered(arg1.name)){
		*result = 1;
		return TRUE;
	}
	if(!find_element_byname(connected_users,arg1.name)){
		*result = 2;
		return TRUE;
	}

	size_t dir_path_size = strlen(USERS_DIRECTORY) +1 + strlen(arg1.name) + 2;
	char * dir_path = (char *)malloc(dir_path_size * sizeof(char));
	sprintf(dir_path,"%s/%s/",USERS_DIRECTORY,arg1.name);
	if(file_exists(arg1.file_name,dir_path)){
		free(dir_path);
		*result = 3;
		return TRUE;
	}
	strncat(dir_path,arg1.file_name,strlen(arg1.file_name));
	int file;
	if((file=open(dir_path, O_CREAT | O_RDWR,0664))==-1){
		perror("Error when creating file");
		free(dir_path);
		*result = 4;
		return TRUE;
	}
	if((write(file,arg1.file_description,strlen(arg1.file_description)))==-1){
		perror("Error when writing description to file");
		close(file);
		free(dir_path);
		*result = 4;
		return TRUE;
	}
	close(file);
	free(dir_path);
	*result = 0;
	return TRUE;
}

bool_t
delete_file_rpc_1_svc(delete_arguments arg1, int *result,  struct svc_req *rqstp)
{
	size_t dir_path_size = strlen(USERS_DIRECTORY) +1 + strlen(arg1.name) + 2;
	char * dir_path = (char *)malloc(dir_path_size * sizeof(char));
	sprintf(dir_path,"%s/%s/",USERS_DIRECTORY,arg1.name);
	if(!file_exists(arg1.file_name,dir_path)){
		free(dir_path);
		*result = 3;
		return TRUE;
	}
	strncat(dir_path,arg1.file_name,strlen(arg1.file_name));
	if((remove(dir_path))==-1){
		perror("Error when removing file");
		free(dir_path);
		*result = 4;
		return TRUE;
	}
	free(dir_path);
	*result = 0;
	return TRUE;
}

bool_t
list_users_1_svc(char *arg1, UserList *result,  struct svc_req *rqstp)
{
	
	result->UserList_len = list_get_size(connected_users);

	UserServerData * users = get_elements(connected_users);

	if(users == NULL){
		dumb_data_error(NULL,result,1);
		return TRUE;
	}
	
	result->UserList_val = malloc(sizeof(UserServer)*result->UserList_len); 

	for (size_t ii = 0; ii < result->UserList_len; ii++)
	{
		UserServer tmp;
		tmp.name = malloc(MAX_SIZE);
		if(tmp.name == NULL){
			dumb_data_error(NULL,result,1);
			return TRUE;
		}
		tmp.ip = malloc(IP_SIZE);
		if(tmp.ip == NULL){
			dumb_data_error(NULL,result,1);
			return TRUE;
		}
		tmp.port = malloc(PORT_SIZE);
		if(tmp.port == NULL){
			dumb_data_error(NULL,result,1);
			return TRUE;
		}

		strcpy(tmp.name,users[ii].name);
		strcpy(tmp.ip,users[ii].ip_address);
		strcpy(tmp.port,users[ii].port);
		printf("%s---%s---%s\n",tmp.name,tmp.ip,tmp.port);

		result->UserList_val[ii] = tmp;
	}
	return TRUE;
}

bool_t
list_content_1_svc(char *arg1, char *arg2, TitleList *result,  struct svc_req *rqstp)
{
	/* arg1 userop */
	/* arg2 user_name */

	if(!isusr_registered(arg2)){
		dumb_data_error(result,NULL,2);
		return TRUE;
	}

	DIR * directory;
	struct dirent * d_entry;
	size_t dir_path_size = strlen(arg2) + 2 + strlen(USERS_DIRECTORY) + 1;
	char dir_path [dir_path_size];
	sprintf(dir_path,"%s/%s/",USERS_DIRECTORY,arg2);

	if((directory= opendir(dir_path))==NULL){
		perror("Error when opening users directory");
		closedir(directory);
		dumb_data_error(result,NULL,0);
		return TRUE;
	}
	result->TitleList_len = 0;
	while ((d_entry = readdir(directory))){
			if(!strcmp(d_entry->d_name, ".") || !strcmp(d_entry->d_name, "..")) {
				continue;
          	}
		result->TitleList_len++;		
	}
	rewinddir(directory);

	result->TitleList_val = malloc(sizeof(Title)*result->TitleList_len);


	int index = 0;
	while ((d_entry = readdir(directory))){
		if(!strcmp(d_entry->d_name, ".") || !strcmp(d_entry->d_name, "..")) {
			continue;
        }
		size_t data_length = strlen(d_entry->d_name)+1;
		char user_file_name [data_length];
		sprintf(user_file_name,"%s",d_entry->d_name);

		Title tmp;
		
		tmp.file_name = malloc(MAX_SIZE);
		if(tmp.file_name == NULL){
			dumb_data_error(result,NULL,0);
			return TRUE;
		}
		
		strcpy(tmp.file_name,user_file_name);
	
		result->TitleList_val[index] = tmp;
		index++;
	}		
	return TRUE;
}

bool_t
is_user_registered_1_svc(char *arg1, int *result,  struct svc_req *rqstp)
{

	/*
	 * insert server code here
	 */

	return 1;
}

bool_t
is_user_connected_1_svc(char *arg1, int *result,  struct svc_req *rqstp)
{

	/*
	 * insert server code here
	 */

	return 1;
}

int
storage_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
